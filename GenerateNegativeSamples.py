
##################################################################
''''''
''''''
'''
This file is to Generate the negative samples, with the sample size and form 
as the training and testing data
1. The negative samples are generated by the random method.
2. The negatiev samples should not have any element in commone with the training or 
    testing samples.
'''
''''''
''''''

#############################################################################
import os
import json
import random
import copy
########################################################################### 
'''
Generate_random_negative: 
    a function to generate negative samples with the same pattern and size of the input data.
    By negative samples, we mean the randomly generated samples, and they are not in the data.
Input:
    data: 
        a list of core paires, which is the output of the module of FrameConstraint
    sample_size:
        the size of the negative samples need to be generated
Output:
    negative_samples:
         a list of randomly generated cores, with the element in the form of 
         [['ALA','GLU'], ['TYR','MET'], -1, -1]
         The length of the negative sampels equals to the sample size
         
*****************Important to know***********************
When we generate the negative samples, we have to use the training samples as the reference 
to decide whether the randomly generated samples are negative or not. The testing samples can not
be used because the testing samples are samples that we pretend don't know when we build this model.
'''          
def Generate_random_negative(data, sample_size):
    
    TripleSingle =  [['TYR', 'Y'], ['LYS', 'K'],['ASP', 'D'], ['ASN', 'N'], ['TRP', 'W'], ['PHE', 'F'], ['GLN', 'Q'],
                    ['GLU', 'E'], ['PRO', 'P'], ['GLY', 'G'], ['THR', 'T'],['SER', 'S'], ['ARG', 'R'], ['HIS', 'H'],
                    ['LEU', 'L'], ['ILE', 'I'], ['CYS', 'C'], ['ALA', 'A'], ['MET', 'M'], ['VAL', 'V']]
    AA = []
    for aa in TripleSingle:
        AA.append(aa[0])
     
    Ab_Ag = []
    for parepi in data:
        Ab_Ag.append([parepi[0], parepi[1]])
        
    Ab_length = len(Ab_Ag[0][0])
    Ag_length = len(Ab_Ag[0][1])
    
    negative_samples = []
    while len(negative_samples) < sample_size:
        r_Ab_r_Ag = []
        while r_Ab_r_Ag == []:        
            r_Ab = With_replacement_sample(AA, Ab_length)
            r_Ag = With_replacement_sample(AA, Ag_length)
            r_Ab_r_Ag  = [r_Ab, r_Ag]
            if r_Ab_r_Ag in Ab_Ag:
                r_Ab_r_Ag  = []
        negative_samples.append([r_Ab, r_Ag, -1, -1])
    return negative_samples

def With_replacement_sample(population, size):
    sample = []
    while len(sample) < size:
        sample.extend(random.sample(population,1))
    return sample
###############################################################

def main():
    # Set the working directory and the saving directory
    wd = '/home/leo/Documents/Database/Pipeline_New/Cores'
    # we want to generate 10 negative samples
    for n in range(10):
        sd = '/home/leo/Documents/Database/Pipeline_New/Negative_Cores/'+'Sample_'+str(n)        

        for i in range(1, 7):
            for j in range(1,7):                
                for k in [0]:                        
                    for h in [1]:                                                                   

                        train_name ='training_' + str(i)+'_'+str(j)+'_'+str(k)+'_'+str(k)+'_1_2_'+str(h)+'perchain'
                        test_name = 'testing_' + str(i)+'_'+str(j)+'_'+str(k)+'_'+str(k)+'_1_2_'+str(h)+'perchain'
                        print('working on '+ train_name + '\n' + test_name)

                        # Save the core aa
                        os.chdir(wd)
                        with open(train_name, 'r') as f:
                            data = json.load(f)
                        with open(test_name, 'r') as f:
                            testing_data = json.load(f)
                        
                        
                        # Generate the negative samples
                        negative_testing_samples = Generate_random_negative(data, len(testing_data))
                        negative_training_samples = Generate_random_negative(data, len(data))
                        
                        # Save the negative samples
                        os.chdir(sd)
                        with open(test_name+'_negative', 'w') as f:
                            json.dump(negative_testing_samples, f)
                        with open(train_name + '_negative', 'w') as f:
                            json.dump(negative_training_samples, f)

   
####################################################################
#if __name__ == '__main__':
#    main()
os.chdir('/home/leo/Documents/Database/Pipeline_New/Negative_Cores/Sample_0')
with open('testing_1_1_0_0_1_2_1perchain_negative', 'r') as f:
    training_1_1 = json.load(f)
#len(training_1_1)
####################################################################
'''
sd: the saving directory
'''
sd = '/home/leo/Documents/Database/Pipeline_New/Latest/Negative_cores'
def Negative_the_latest(sd):
    # Get the training set by combining all the previous    
    for i in range(1,5):
        for j in range(1, 5):
            train_name = 'training_'+str(i)+'_'+str(j)+'_0_0_1_2_1perchain'
            test_name = 'testing_'+str(i)+'_'+str(j)+'_0_0_1_2_1perchain'
            os.chdir('/home/leo/Documents/Database/Pipeline_New/Cores')
            with open(train_name, 'r') as f:
                train_old = json.load(f)
            with open(test_name, 'r') as f:
                test_old = json.load(f)
            train = copy.deepcopy(train_old)
            train.extend(test_old)
            
            os.chdir('/home/leo/Documents/Database/Pipeline_New/Latest/cores')
            with open(test_name, 'r') as f:
                test_new = json.load(f)
            # Generate the negative samples
            for n in range(10):            
                save_directory =  sd + '/sample_'+str(n)
                print('Generating '+ test_name)
                negative_test =  Generate_random_negative(train, len(test_new))
                print('Generating '+ train_name)
                negative_train = Generate_random_negative(train, len(train))
                # Same the negative samples
                os.chdir(save_directory)
                save_name_test = test_name + '_negative'
                save_name_train = train_name + '_negative'
                with open(save_name_test, 'w') as f:
                    json.dump(negative_test, f)
                with open(save_name_train, 'w') as f:
                    json.dump(negative_train, f)
#Negative_the_latest(sd)  
#os.chdir('/home/leo/Documents/Database/Pipeline_New/Negative_Cores/Sample_0')  
#with open('training_1_1_0_0_1_2_1perchain_negative', 'r') as f: 
#    train = json.load(f)   
#len(train)                      
'''
Need to take a look at the negative samples, make sure they have nothing in common with the real cores
'''
#def Check():
#        # Set the working directory and the saving directory
#    wd = '/home/leo/Documents/Database/Pipeline_New/Cores'
#    # we want to generate 10 negative samples
#    for n in range(10):
#        sd = '/home/leo/Documents/Database/Pipeline_New/Negative_Cores/'+'Sample_'+str(n)        
#        for i in range(1, 5):
#            for j in range(1, 5):                
#                for k in [1, 0]:                        
#                    for h in [1, 2, 3]:                                                                   
#
#                        name = str(i)+'_'+str(j)+'_'+str(k)+'_'+str(k)+'_1_2_'+str(h)+'perchain'
#
#                        # Save the core aa
#                        os.chdir(wd)
#                        with open('training_'+name, 'r') as f:
#                            positive_training_data = json.load(f)
#                            
#                        with open('testing_'+name, 'r') as f:
#                            positive_testing_data = json.load(f)                            
#                        
#                        # Save the negative samples
#                        os.chdir(sd)
#                        save_name =  name + '_negative'
#                        with open('testing_'+save_name, 'r') as f:
#                            negative_testing_data = json.load( f)
#                        with open('training_'+save_name, 'r') as f:
#                            negative_training_data = json.load(f)
#                            
#                        # Check 
#                        res1 = Subcheck(positive_training_data, negative_testing_data)
#                        res2 = Subcheck(positive_training_data, negative_training_data)
#                        
#                        if res1 and res2 and len(positive_testing_data)== len(negative_testing_data):
#                            print(' Correct')
#                        else:
#                            print(print(name+'\n not correct'))
#
#                    os.chdir(wd)
#                    with open('training_'+name, 'r') as f:
#                        positive_training_data = json.load(f)
#                        
#                    with open('testing_'+name, 'r') as f:
#                        positive_testing_data = json.load(f)                            
#                    
#                    # Save the negative samples
#                    os.chdir(sd)
#                    save_name = name + '_negative'
#                    with open('testing_'+save_name, 'r') as f:
#                        negative_testing_data = json.load( f)
#                    with open('training_'+save_name, 'r') as f:
#                        negative_training_data = json.load(f)
#                        
#                    # Check 
#                    res1 = Subcheck(positive_training_data, negative_testing_data)
#                    res2 = Subcheck(positive_training_data, negative_training_data)
#                    
#                    if res1 and res2 and len(positive_testing_data)== len(negative_testing_data):
#                        print(' Correct')
#                    else:
#                        print(print(name+'\n not correct'))    
#    
#        
#def Subcheck(data, sub_data):
#    res = True
#    pool = [x[:2] for x in data]
#    for sub in sub_data:
#        if sub[:] in pool:
#            res = False
#            break
#    return res
#    
#        
#Check()        
 
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
